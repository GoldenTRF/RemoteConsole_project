// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: RemoteConsole.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_RemoteConsole_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_RemoteConsole_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_bases.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_RemoteConsole_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_RemoteConsole_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_RemoteConsole_2eproto;
namespace RemoteConsole {
class AuthorizationReply;
struct AuthorizationReplyDefaultTypeInternal;
extern AuthorizationReplyDefaultTypeInternal _AuthorizationReply_default_instance_;
class AuthorizationRequest;
struct AuthorizationRequestDefaultTypeInternal;
extern AuthorizationRequestDefaultTypeInternal _AuthorizationRequest_default_instance_;
class CharChank;
struct CharChankDefaultTypeInternal;
extern CharChankDefaultTypeInternal _CharChank_default_instance_;
class CursorMess;
struct CursorMessDefaultTypeInternal;
extern CursorMessDefaultTypeInternal _CursorMess_default_instance_;
class Empty;
struct EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class KeyEventMess;
struct KeyEventMessDefaultTypeInternal;
extern KeyEventMessDefaultTypeInternal _KeyEventMess_default_instance_;
class MouseEventMess;
struct MouseEventMessDefaultTypeInternal;
extern MouseEventMessDefaultTypeInternal _MouseEventMess_default_instance_;
}  // namespace RemoteConsole
PROTOBUF_NAMESPACE_OPEN
template<> ::RemoteConsole::AuthorizationReply* Arena::CreateMaybeMessage<::RemoteConsole::AuthorizationReply>(Arena*);
template<> ::RemoteConsole::AuthorizationRequest* Arena::CreateMaybeMessage<::RemoteConsole::AuthorizationRequest>(Arena*);
template<> ::RemoteConsole::CharChank* Arena::CreateMaybeMessage<::RemoteConsole::CharChank>(Arena*);
template<> ::RemoteConsole::CursorMess* Arena::CreateMaybeMessage<::RemoteConsole::CursorMess>(Arena*);
template<> ::RemoteConsole::Empty* Arena::CreateMaybeMessage<::RemoteConsole::Empty>(Arena*);
template<> ::RemoteConsole::KeyEventMess* Arena::CreateMaybeMessage<::RemoteConsole::KeyEventMess>(Arena*);
template<> ::RemoteConsole::MouseEventMess* Arena::CreateMaybeMessage<::RemoteConsole::MouseEventMess>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace RemoteConsole {

// ===================================================================

class AuthorizationRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.AuthorizationRequest) */ {
 public:
  inline AuthorizationRequest() : AuthorizationRequest(nullptr) {}
  ~AuthorizationRequest() override;
  explicit PROTOBUF_CONSTEXPR AuthorizationRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationRequest(const AuthorizationRequest& from);
  AuthorizationRequest(AuthorizationRequest&& from) noexcept
    : AuthorizationRequest() {
    *this = ::std::move(from);
  }

  inline AuthorizationRequest& operator=(const AuthorizationRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationRequest& operator=(AuthorizationRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationRequest* internal_default_instance() {
    return reinterpret_cast<const AuthorizationRequest*>(
               &_AuthorizationRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AuthorizationRequest& a, AuthorizationRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthorizationRequest& from) {
    AuthorizationRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.AuthorizationRequest";
  }
  protected:
  explicit AuthorizationRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kClientPasswordFieldNumber = 1,
    kClientLoginFieldNumber = 2,
  };
  // string clientPassword = 1;
  void clear_clientpassword();
  const std::string& clientpassword() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientpassword(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientpassword();
  PROTOBUF_NODISCARD std::string* release_clientpassword();
  void set_allocated_clientpassword(std::string* clientpassword);
  private:
  const std::string& _internal_clientpassword() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientpassword(const std::string& value);
  std::string* _internal_mutable_clientpassword();
  public:

  // string clientLogin = 2;
  void clear_clientlogin();
  const std::string& clientlogin() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_clientlogin(ArgT0&& arg0, ArgT... args);
  std::string* mutable_clientlogin();
  PROTOBUF_NODISCARD std::string* release_clientlogin();
  void set_allocated_clientlogin(std::string* clientlogin);
  private:
  const std::string& _internal_clientlogin() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_clientlogin(const std::string& value);
  std::string* _internal_mutable_clientlogin();
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.AuthorizationRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientpassword_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr clientlogin_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class AuthorizationReply final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.AuthorizationReply) */ {
 public:
  inline AuthorizationReply() : AuthorizationReply(nullptr) {}
  ~AuthorizationReply() override;
  explicit PROTOBUF_CONSTEXPR AuthorizationReply(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AuthorizationReply(const AuthorizationReply& from);
  AuthorizationReply(AuthorizationReply&& from) noexcept
    : AuthorizationReply() {
    *this = ::std::move(from);
  }

  inline AuthorizationReply& operator=(const AuthorizationReply& from) {
    CopyFrom(from);
    return *this;
  }
  inline AuthorizationReply& operator=(AuthorizationReply&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AuthorizationReply& default_instance() {
    return *internal_default_instance();
  }
  static inline const AuthorizationReply* internal_default_instance() {
    return reinterpret_cast<const AuthorizationReply*>(
               &_AuthorizationReply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AuthorizationReply& a, AuthorizationReply& b) {
    a.Swap(&b);
  }
  inline void Swap(AuthorizationReply* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AuthorizationReply* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AuthorizationReply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AuthorizationReply>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AuthorizationReply& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AuthorizationReply& from) {
    AuthorizationReply::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AuthorizationReply* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.AuthorizationReply";
  }
  protected:
  explicit AuthorizationReply(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSuccessfulFieldNumber = 1,
  };
  // bool isSuccessful = 1;
  void clear_issuccessful();
  bool issuccessful() const;
  void set_issuccessful(bool value);
  private:
  bool _internal_issuccessful() const;
  void _internal_set_issuccessful(bool value);
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.AuthorizationReply)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool issuccessful_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class CharChank final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.CharChank) */ {
 public:
  inline CharChank() : CharChank(nullptr) {}
  ~CharChank() override;
  explicit PROTOBUF_CONSTEXPR CharChank(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CharChank(const CharChank& from);
  CharChank(CharChank&& from) noexcept
    : CharChank() {
    *this = ::std::move(from);
  }

  inline CharChank& operator=(const CharChank& from) {
    CopyFrom(from);
    return *this;
  }
  inline CharChank& operator=(CharChank&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CharChank& default_instance() {
    return *internal_default_instance();
  }
  static inline const CharChank* internal_default_instance() {
    return reinterpret_cast<const CharChank*>(
               &_CharChank_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(CharChank& a, CharChank& b) {
    a.Swap(&b);
  }
  inline void Swap(CharChank* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CharChank* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CharChank* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CharChank>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CharChank& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CharChank& from) {
    CharChank::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CharChank* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.CharChank";
  }
  protected:
  explicit CharChank(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunkFieldNumber = 1,
  };
  // bytes chunk = 1;
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_NODISCARD std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.CharChank)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class CursorMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.CursorMess) */ {
 public:
  inline CursorMess() : CursorMess(nullptr) {}
  ~CursorMess() override;
  explicit PROTOBUF_CONSTEXPR CursorMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CursorMess(const CursorMess& from);
  CursorMess(CursorMess&& from) noexcept
    : CursorMess() {
    *this = ::std::move(from);
  }

  inline CursorMess& operator=(const CursorMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline CursorMess& operator=(CursorMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CursorMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const CursorMess* internal_default_instance() {
    return reinterpret_cast<const CursorMess*>(
               &_CursorMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(CursorMess& a, CursorMess& b) {
    a.Swap(&b);
  }
  inline void Swap(CursorMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CursorMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CursorMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CursorMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CursorMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CursorMess& from) {
    CursorMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CursorMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.CursorMess";
  }
  protected:
  explicit CursorMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCursorXFieldNumber = 1,
    kCursorYFieldNumber = 2,
  };
  // int32 cursorX = 1;
  void clear_cursorx();
  int32_t cursorx() const;
  void set_cursorx(int32_t value);
  private:
  int32_t _internal_cursorx() const;
  void _internal_set_cursorx(int32_t value);
  public:

  // int32 cursorY = 2;
  void clear_cursory();
  int32_t cursory() const;
  void set_cursory(int32_t value);
  private:
  int32_t _internal_cursory() const;
  void _internal_set_cursory(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.CursorMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t cursorx_;
    int32_t cursory_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class KeyEventMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.KeyEventMess) */ {
 public:
  inline KeyEventMess() : KeyEventMess(nullptr) {}
  ~KeyEventMess() override;
  explicit PROTOBUF_CONSTEXPR KeyEventMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  KeyEventMess(const KeyEventMess& from);
  KeyEventMess(KeyEventMess&& from) noexcept
    : KeyEventMess() {
    *this = ::std::move(from);
  }

  inline KeyEventMess& operator=(const KeyEventMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline KeyEventMess& operator=(KeyEventMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const KeyEventMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const KeyEventMess* internal_default_instance() {
    return reinterpret_cast<const KeyEventMess*>(
               &_KeyEventMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(KeyEventMess& a, KeyEventMess& b) {
    a.Swap(&b);
  }
  inline void Swap(KeyEventMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(KeyEventMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  KeyEventMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<KeyEventMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const KeyEventMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const KeyEventMess& from) {
    KeyEventMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(KeyEventMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.KeyEventMess";
  }
  protected:
  explicit KeyEventMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyDownFieldNumber = 1,
    kWRepCountFieldNumber = 2,
    kVirtualKeyCodeFieldNumber = 3,
    kVirtualScanCodeFieldNumber = 4,
    kControlKeyStateFieldNumber = 5,
    kUnicodeCharFieldNumber = 6,
    kAsciiCharFieldNumber = 7,
  };
  // bool keyDown = 1;
  void clear_keydown();
  bool keydown() const;
  void set_keydown(bool value);
  private:
  bool _internal_keydown() const;
  void _internal_set_keydown(bool value);
  public:

  // uint32 wRepCount = 2;
  void clear_wrepcount();
  uint32_t wrepcount() const;
  void set_wrepcount(uint32_t value);
  private:
  uint32_t _internal_wrepcount() const;
  void _internal_set_wrepcount(uint32_t value);
  public:

  // uint32 virtualKeyCode = 3;
  void clear_virtualkeycode();
  uint32_t virtualkeycode() const;
  void set_virtualkeycode(uint32_t value);
  private:
  uint32_t _internal_virtualkeycode() const;
  void _internal_set_virtualkeycode(uint32_t value);
  public:

  // uint32 virtualScanCode = 4;
  void clear_virtualscancode();
  uint32_t virtualscancode() const;
  void set_virtualscancode(uint32_t value);
  private:
  uint32_t _internal_virtualscancode() const;
  void _internal_set_virtualscancode(uint32_t value);
  public:

  // uint32 controlKeyState = 5;
  void clear_controlkeystate();
  uint32_t controlkeystate() const;
  void set_controlkeystate(uint32_t value);
  private:
  uint32_t _internal_controlkeystate() const;
  void _internal_set_controlkeystate(uint32_t value);
  public:

  // uint32 unicode_char = 6;
  void clear_unicode_char();
  uint32_t unicode_char() const;
  void set_unicode_char(uint32_t value);
  private:
  uint32_t _internal_unicode_char() const;
  void _internal_set_unicode_char(uint32_t value);
  public:

  // uint32 ascii_char = 7;
  void clear_ascii_char();
  uint32_t ascii_char() const;
  void set_ascii_char(uint32_t value);
  private:
  uint32_t _internal_ascii_char() const;
  void _internal_set_ascii_char(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.KeyEventMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    bool keydown_;
    uint32_t wrepcount_;
    uint32_t virtualkeycode_;
    uint32_t virtualscancode_;
    uint32_t controlkeystate_;
    uint32_t unicode_char_;
    uint32_t ascii_char_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class MouseEventMess final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteConsole.MouseEventMess) */ {
 public:
  inline MouseEventMess() : MouseEventMess(nullptr) {}
  ~MouseEventMess() override;
  explicit PROTOBUF_CONSTEXPR MouseEventMess(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  MouseEventMess(const MouseEventMess& from);
  MouseEventMess(MouseEventMess&& from) noexcept
    : MouseEventMess() {
    *this = ::std::move(from);
  }

  inline MouseEventMess& operator=(const MouseEventMess& from) {
    CopyFrom(from);
    return *this;
  }
  inline MouseEventMess& operator=(MouseEventMess&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const MouseEventMess& default_instance() {
    return *internal_default_instance();
  }
  static inline const MouseEventMess* internal_default_instance() {
    return reinterpret_cast<const MouseEventMess*>(
               &_MouseEventMess_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(MouseEventMess& a, MouseEventMess& b) {
    a.Swap(&b);
  }
  inline void Swap(MouseEventMess* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(MouseEventMess* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  MouseEventMess* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<MouseEventMess>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const MouseEventMess& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const MouseEventMess& from) {
    MouseEventMess::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(MouseEventMess* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.MouseEventMess";
  }
  protected:
  explicit MouseEventMess(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMouseXFieldNumber = 1,
    kMouseYFieldNumber = 2,
    kButtonStateFieldNumber = 3,
    kControlKeyStateFieldNumber = 4,
    kEventFlagFieldNumber = 5,
  };
  // uint32 mouseX = 1;
  void clear_mousex();
  uint32_t mousex() const;
  void set_mousex(uint32_t value);
  private:
  uint32_t _internal_mousex() const;
  void _internal_set_mousex(uint32_t value);
  public:

  // uint32 mouseY = 2;
  void clear_mousey();
  uint32_t mousey() const;
  void set_mousey(uint32_t value);
  private:
  uint32_t _internal_mousey() const;
  void _internal_set_mousey(uint32_t value);
  public:

  // uint32 buttonState = 3;
  void clear_buttonstate();
  uint32_t buttonstate() const;
  void set_buttonstate(uint32_t value);
  private:
  uint32_t _internal_buttonstate() const;
  void _internal_set_buttonstate(uint32_t value);
  public:

  // uint32 controlKeyState = 4;
  void clear_controlkeystate();
  uint32_t controlkeystate() const;
  void set_controlkeystate(uint32_t value);
  private:
  uint32_t _internal_controlkeystate() const;
  void _internal_set_controlkeystate(uint32_t value);
  public:

  // uint32 eventFlag = 5;
  void clear_eventflag();
  uint32_t eventflag() const;
  void set_eventflag(uint32_t value);
  private:
  uint32_t _internal_eventflag() const;
  void _internal_set_eventflag(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:RemoteConsole.MouseEventMess)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    uint32_t mousex_;
    uint32_t mousey_;
    uint32_t buttonstate_;
    uint32_t controlkeystate_;
    uint32_t eventflag_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// -------------------------------------------------------------------

class Empty final :
    public ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase /* @@protoc_insertion_point(class_definition:RemoteConsole.Empty) */ {
 public:
  inline Empty() : Empty(nullptr) {}
  explicit PROTOBUF_CONSTEXPR Empty(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Empty(const Empty& from);
  Empty(Empty&& from) noexcept
    : Empty() {
    *this = ::std::move(from);
  }

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }
  inline Empty& operator=(Empty&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Empty& default_instance() {
    return *internal_default_instance();
  }
  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(Empty& a, Empty& b) {
    a.Swap(&b);
  }
  inline void Swap(Empty* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Empty* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Empty* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Empty>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyFrom;
  inline void CopyFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::CopyImpl(*this, from);
  }
  using ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeFrom;
  void MergeFrom(const Empty& from) {
    ::PROTOBUF_NAMESPACE_ID::internal::ZeroFieldsBase::MergeImpl(*this, from);
  }
  public:

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteConsole.Empty";
  }
  protected:
  explicit Empty(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:RemoteConsole.Empty)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
  };
  friend struct ::TableStruct_RemoteConsole_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AuthorizationRequest

// string clientPassword = 1;
inline void AuthorizationRequest::clear_clientpassword() {
  _impl_.clientpassword_.ClearToEmpty();
}
inline const std::string& AuthorizationRequest::clientpassword() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.AuthorizationRequest.clientPassword)
  return _internal_clientpassword();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationRequest::set_clientpassword(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientpassword_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteConsole.AuthorizationRequest.clientPassword)
}
inline std::string* AuthorizationRequest::mutable_clientpassword() {
  std::string* _s = _internal_mutable_clientpassword();
  // @@protoc_insertion_point(field_mutable:RemoteConsole.AuthorizationRequest.clientPassword)
  return _s;
}
inline const std::string& AuthorizationRequest::_internal_clientpassword() const {
  return _impl_.clientpassword_.Get();
}
inline void AuthorizationRequest::_internal_set_clientpassword(const std::string& value) {
  
  _impl_.clientpassword_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationRequest::_internal_mutable_clientpassword() {
  
  return _impl_.clientpassword_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationRequest::release_clientpassword() {
  // @@protoc_insertion_point(field_release:RemoteConsole.AuthorizationRequest.clientPassword)
  return _impl_.clientpassword_.Release();
}
inline void AuthorizationRequest::set_allocated_clientpassword(std::string* clientpassword) {
  if (clientpassword != nullptr) {
    
  } else {
    
  }
  _impl_.clientpassword_.SetAllocated(clientpassword, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientpassword_.IsDefault()) {
    _impl_.clientpassword_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoteConsole.AuthorizationRequest.clientPassword)
}

// string clientLogin = 2;
inline void AuthorizationRequest::clear_clientlogin() {
  _impl_.clientlogin_.ClearToEmpty();
}
inline const std::string& AuthorizationRequest::clientlogin() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.AuthorizationRequest.clientLogin)
  return _internal_clientlogin();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AuthorizationRequest::set_clientlogin(ArgT0&& arg0, ArgT... args) {
 
 _impl_.clientlogin_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteConsole.AuthorizationRequest.clientLogin)
}
inline std::string* AuthorizationRequest::mutable_clientlogin() {
  std::string* _s = _internal_mutable_clientlogin();
  // @@protoc_insertion_point(field_mutable:RemoteConsole.AuthorizationRequest.clientLogin)
  return _s;
}
inline const std::string& AuthorizationRequest::_internal_clientlogin() const {
  return _impl_.clientlogin_.Get();
}
inline void AuthorizationRequest::_internal_set_clientlogin(const std::string& value) {
  
  _impl_.clientlogin_.Set(value, GetArenaForAllocation());
}
inline std::string* AuthorizationRequest::_internal_mutable_clientlogin() {
  
  return _impl_.clientlogin_.Mutable(GetArenaForAllocation());
}
inline std::string* AuthorizationRequest::release_clientlogin() {
  // @@protoc_insertion_point(field_release:RemoteConsole.AuthorizationRequest.clientLogin)
  return _impl_.clientlogin_.Release();
}
inline void AuthorizationRequest::set_allocated_clientlogin(std::string* clientlogin) {
  if (clientlogin != nullptr) {
    
  } else {
    
  }
  _impl_.clientlogin_.SetAllocated(clientlogin, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.clientlogin_.IsDefault()) {
    _impl_.clientlogin_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoteConsole.AuthorizationRequest.clientLogin)
}

// -------------------------------------------------------------------

// AuthorizationReply

// bool isSuccessful = 1;
inline void AuthorizationReply::clear_issuccessful() {
  _impl_.issuccessful_ = false;
}
inline bool AuthorizationReply::_internal_issuccessful() const {
  return _impl_.issuccessful_;
}
inline bool AuthorizationReply::issuccessful() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.AuthorizationReply.isSuccessful)
  return _internal_issuccessful();
}
inline void AuthorizationReply::_internal_set_issuccessful(bool value) {
  
  _impl_.issuccessful_ = value;
}
inline void AuthorizationReply::set_issuccessful(bool value) {
  _internal_set_issuccessful(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.AuthorizationReply.isSuccessful)
}

// -------------------------------------------------------------------

// CharChank

// bytes chunk = 1;
inline void CharChank::clear_chunk() {
  _impl_.chunk_.ClearToEmpty();
}
inline const std::string& CharChank::chunk() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.CharChank.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CharChank::set_chunk(ArgT0&& arg0, ArgT... args) {
 
 _impl_.chunk_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteConsole.CharChank.chunk)
}
inline std::string* CharChank::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:RemoteConsole.CharChank.chunk)
  return _s;
}
inline const std::string& CharChank::_internal_chunk() const {
  return _impl_.chunk_.Get();
}
inline void CharChank::_internal_set_chunk(const std::string& value) {
  
  _impl_.chunk_.Set(value, GetArenaForAllocation());
}
inline std::string* CharChank::_internal_mutable_chunk() {
  
  return _impl_.chunk_.Mutable(GetArenaForAllocation());
}
inline std::string* CharChank::release_chunk() {
  // @@protoc_insertion_point(field_release:RemoteConsole.CharChank.chunk)
  return _impl_.chunk_.Release();
}
inline void CharChank::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  _impl_.chunk_.SetAllocated(chunk, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.chunk_.IsDefault()) {
    _impl_.chunk_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:RemoteConsole.CharChank.chunk)
}

// -------------------------------------------------------------------

// CursorMess

// int32 cursorX = 1;
inline void CursorMess::clear_cursorx() {
  _impl_.cursorx_ = 0;
}
inline int32_t CursorMess::_internal_cursorx() const {
  return _impl_.cursorx_;
}
inline int32_t CursorMess::cursorx() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.CursorMess.cursorX)
  return _internal_cursorx();
}
inline void CursorMess::_internal_set_cursorx(int32_t value) {
  
  _impl_.cursorx_ = value;
}
inline void CursorMess::set_cursorx(int32_t value) {
  _internal_set_cursorx(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.CursorMess.cursorX)
}

// int32 cursorY = 2;
inline void CursorMess::clear_cursory() {
  _impl_.cursory_ = 0;
}
inline int32_t CursorMess::_internal_cursory() const {
  return _impl_.cursory_;
}
inline int32_t CursorMess::cursory() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.CursorMess.cursorY)
  return _internal_cursory();
}
inline void CursorMess::_internal_set_cursory(int32_t value) {
  
  _impl_.cursory_ = value;
}
inline void CursorMess::set_cursory(int32_t value) {
  _internal_set_cursory(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.CursorMess.cursorY)
}

// -------------------------------------------------------------------

// KeyEventMess

// bool keyDown = 1;
inline void KeyEventMess::clear_keydown() {
  _impl_.keydown_ = false;
}
inline bool KeyEventMess::_internal_keydown() const {
  return _impl_.keydown_;
}
inline bool KeyEventMess::keydown() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.keyDown)
  return _internal_keydown();
}
inline void KeyEventMess::_internal_set_keydown(bool value) {
  
  _impl_.keydown_ = value;
}
inline void KeyEventMess::set_keydown(bool value) {
  _internal_set_keydown(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.keyDown)
}

// uint32 wRepCount = 2;
inline void KeyEventMess::clear_wrepcount() {
  _impl_.wrepcount_ = 0u;
}
inline uint32_t KeyEventMess::_internal_wrepcount() const {
  return _impl_.wrepcount_;
}
inline uint32_t KeyEventMess::wrepcount() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.wRepCount)
  return _internal_wrepcount();
}
inline void KeyEventMess::_internal_set_wrepcount(uint32_t value) {
  
  _impl_.wrepcount_ = value;
}
inline void KeyEventMess::set_wrepcount(uint32_t value) {
  _internal_set_wrepcount(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.wRepCount)
}

// uint32 virtualKeyCode = 3;
inline void KeyEventMess::clear_virtualkeycode() {
  _impl_.virtualkeycode_ = 0u;
}
inline uint32_t KeyEventMess::_internal_virtualkeycode() const {
  return _impl_.virtualkeycode_;
}
inline uint32_t KeyEventMess::virtualkeycode() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.virtualKeyCode)
  return _internal_virtualkeycode();
}
inline void KeyEventMess::_internal_set_virtualkeycode(uint32_t value) {
  
  _impl_.virtualkeycode_ = value;
}
inline void KeyEventMess::set_virtualkeycode(uint32_t value) {
  _internal_set_virtualkeycode(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.virtualKeyCode)
}

// uint32 virtualScanCode = 4;
inline void KeyEventMess::clear_virtualscancode() {
  _impl_.virtualscancode_ = 0u;
}
inline uint32_t KeyEventMess::_internal_virtualscancode() const {
  return _impl_.virtualscancode_;
}
inline uint32_t KeyEventMess::virtualscancode() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.virtualScanCode)
  return _internal_virtualscancode();
}
inline void KeyEventMess::_internal_set_virtualscancode(uint32_t value) {
  
  _impl_.virtualscancode_ = value;
}
inline void KeyEventMess::set_virtualscancode(uint32_t value) {
  _internal_set_virtualscancode(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.virtualScanCode)
}

// uint32 controlKeyState = 5;
inline void KeyEventMess::clear_controlkeystate() {
  _impl_.controlkeystate_ = 0u;
}
inline uint32_t KeyEventMess::_internal_controlkeystate() const {
  return _impl_.controlkeystate_;
}
inline uint32_t KeyEventMess::controlkeystate() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.controlKeyState)
  return _internal_controlkeystate();
}
inline void KeyEventMess::_internal_set_controlkeystate(uint32_t value) {
  
  _impl_.controlkeystate_ = value;
}
inline void KeyEventMess::set_controlkeystate(uint32_t value) {
  _internal_set_controlkeystate(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.controlKeyState)
}

// uint32 unicode_char = 6;
inline void KeyEventMess::clear_unicode_char() {
  _impl_.unicode_char_ = 0u;
}
inline uint32_t KeyEventMess::_internal_unicode_char() const {
  return _impl_.unicode_char_;
}
inline uint32_t KeyEventMess::unicode_char() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.unicode_char)
  return _internal_unicode_char();
}
inline void KeyEventMess::_internal_set_unicode_char(uint32_t value) {
  
  _impl_.unicode_char_ = value;
}
inline void KeyEventMess::set_unicode_char(uint32_t value) {
  _internal_set_unicode_char(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.unicode_char)
}

// uint32 ascii_char = 7;
inline void KeyEventMess::clear_ascii_char() {
  _impl_.ascii_char_ = 0u;
}
inline uint32_t KeyEventMess::_internal_ascii_char() const {
  return _impl_.ascii_char_;
}
inline uint32_t KeyEventMess::ascii_char() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.KeyEventMess.ascii_char)
  return _internal_ascii_char();
}
inline void KeyEventMess::_internal_set_ascii_char(uint32_t value) {
  
  _impl_.ascii_char_ = value;
}
inline void KeyEventMess::set_ascii_char(uint32_t value) {
  _internal_set_ascii_char(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.KeyEventMess.ascii_char)
}

// -------------------------------------------------------------------

// MouseEventMess

// uint32 mouseX = 1;
inline void MouseEventMess::clear_mousex() {
  _impl_.mousex_ = 0u;
}
inline uint32_t MouseEventMess::_internal_mousex() const {
  return _impl_.mousex_;
}
inline uint32_t MouseEventMess::mousex() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.MouseEventMess.mouseX)
  return _internal_mousex();
}
inline void MouseEventMess::_internal_set_mousex(uint32_t value) {
  
  _impl_.mousex_ = value;
}
inline void MouseEventMess::set_mousex(uint32_t value) {
  _internal_set_mousex(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.MouseEventMess.mouseX)
}

// uint32 mouseY = 2;
inline void MouseEventMess::clear_mousey() {
  _impl_.mousey_ = 0u;
}
inline uint32_t MouseEventMess::_internal_mousey() const {
  return _impl_.mousey_;
}
inline uint32_t MouseEventMess::mousey() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.MouseEventMess.mouseY)
  return _internal_mousey();
}
inline void MouseEventMess::_internal_set_mousey(uint32_t value) {
  
  _impl_.mousey_ = value;
}
inline void MouseEventMess::set_mousey(uint32_t value) {
  _internal_set_mousey(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.MouseEventMess.mouseY)
}

// uint32 buttonState = 3;
inline void MouseEventMess::clear_buttonstate() {
  _impl_.buttonstate_ = 0u;
}
inline uint32_t MouseEventMess::_internal_buttonstate() const {
  return _impl_.buttonstate_;
}
inline uint32_t MouseEventMess::buttonstate() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.MouseEventMess.buttonState)
  return _internal_buttonstate();
}
inline void MouseEventMess::_internal_set_buttonstate(uint32_t value) {
  
  _impl_.buttonstate_ = value;
}
inline void MouseEventMess::set_buttonstate(uint32_t value) {
  _internal_set_buttonstate(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.MouseEventMess.buttonState)
}

// uint32 controlKeyState = 4;
inline void MouseEventMess::clear_controlkeystate() {
  _impl_.controlkeystate_ = 0u;
}
inline uint32_t MouseEventMess::_internal_controlkeystate() const {
  return _impl_.controlkeystate_;
}
inline uint32_t MouseEventMess::controlkeystate() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.MouseEventMess.controlKeyState)
  return _internal_controlkeystate();
}
inline void MouseEventMess::_internal_set_controlkeystate(uint32_t value) {
  
  _impl_.controlkeystate_ = value;
}
inline void MouseEventMess::set_controlkeystate(uint32_t value) {
  _internal_set_controlkeystate(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.MouseEventMess.controlKeyState)
}

// uint32 eventFlag = 5;
inline void MouseEventMess::clear_eventflag() {
  _impl_.eventflag_ = 0u;
}
inline uint32_t MouseEventMess::_internal_eventflag() const {
  return _impl_.eventflag_;
}
inline uint32_t MouseEventMess::eventflag() const {
  // @@protoc_insertion_point(field_get:RemoteConsole.MouseEventMess.eventFlag)
  return _internal_eventflag();
}
inline void MouseEventMess::_internal_set_eventflag(uint32_t value) {
  
  _impl_.eventflag_ = value;
}
inline void MouseEventMess::set_eventflag(uint32_t value) {
  _internal_set_eventflag(value);
  // @@protoc_insertion_point(field_set:RemoteConsole.MouseEventMess.eventFlag)
}

// -------------------------------------------------------------------

// Empty

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace RemoteConsole

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_RemoteConsole_2eproto
