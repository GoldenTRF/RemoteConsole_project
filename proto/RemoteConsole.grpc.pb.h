// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: RemoteConsole.proto
#ifndef GRPC_RemoteConsole_2eproto__INCLUDED
#define GRPC_RemoteConsole_2eproto__INCLUDED

#include "RemoteConsole.pb.h"

#include <functional>
#include <grpcpp/generic/async_generic_service.h>
#include <grpcpp/support/async_stream.h>
#include <grpcpp/support/async_unary_call.h>
#include <grpcpp/support/client_callback.h>
#include <grpcpp/client_context.h>
#include <grpcpp/completion_queue.h>
#include <grpcpp/support/message_allocator.h>
#include <grpcpp/support/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/rpc_method.h>
#include <grpcpp/support/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/server_context.h>
#include <grpcpp/impl/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/support/stub_options.h>
#include <grpcpp/support/sync_stream.h>

namespace RemoteConsole {

// ====================================================== SERVICES ====================================================
//
class AuthorizationService final {
 public:
  static constexpr char const* service_full_name() {
    return "RemoteConsole.AuthorizationService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // the first connection between server and client. Exist to accept the client connection to the server
    virtual ::grpc::Status primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::AuthorizationReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>> AsyncprimaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>>(AsyncprimaryConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>> PrepareAsyncprimaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>>(PrepareAsyncprimaryConnectionRaw(context, request, cq));
    }
    // Second authorization between cleint and server. Exist to check the client login data to server can accept functions for client
    virtual ::grpc::Status clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::RemoteConsole::AuthorizationReply* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>> AsyncclientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>>(AsyncclientAuthorizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>> PrepareAsyncclientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>>(PrepareAsyncclientAuthorizationRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // the first connection between server and client. Exist to accept the client connection to the server
      virtual void primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      // Second authorization between cleint and server. Exist to check the client login data to server can accept functions for client
      virtual void clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>* AsyncprimaryConnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>* PrepareAsyncprimaryConnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>* AsyncclientAuthorizationRaw(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::AuthorizationReply>* PrepareAsyncclientAuthorizationRaw(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::AuthorizationReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>> AsyncprimaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>>(AsyncprimaryConnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>> PrepareAsyncprimaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>>(PrepareAsyncprimaryConnectionRaw(context, request, cq));
    }
    ::grpc::Status clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::RemoteConsole::AuthorizationReply* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>> AsyncclientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>>(AsyncclientAuthorizationRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>> PrepareAsyncclientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>>(PrepareAsyncclientAuthorizationRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response, std::function<void(::grpc::Status)>) override;
      void primaryConnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response, std::function<void(::grpc::Status)>) override;
      void clientAuthorization(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>* AsyncprimaryConnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>* PrepareAsyncprimaryConnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>* AsyncclientAuthorizationRaw(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::AuthorizationReply>* PrepareAsyncclientAuthorizationRaw(::grpc::ClientContext* context, const ::RemoteConsole::AuthorizationRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_primaryConnection_;
    const ::grpc::internal::RpcMethod rpcmethod_clientAuthorization_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // the first connection between server and client. Exist to accept the client connection to the server
    virtual ::grpc::Status primaryConnection(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response);
    // Second authorization between cleint and server. Exist to check the client login data to server can accept functions for client
    virtual ::grpc::Status clientAuthorization(::grpc::ServerContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_primaryConnection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestprimaryConnection(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::AuthorizationReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclientAuthorization(::grpc::ServerContext* context, ::RemoteConsole::AuthorizationRequest* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::AuthorizationReply>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_primaryConnection<WithAsyncMethod_clientAuthorization<Service > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_primaryConnection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::AuthorizationReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::AuthorizationReply* response) { return this->primaryConnection(context, request, response); }));}
    void SetMessageAllocatorFor_primaryConnection(
        ::grpc::MessageAllocator< ::RemoteConsole::Empty, ::RemoteConsole::AuthorizationReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::AuthorizationReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* primaryConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::AuthorizationRequest, ::RemoteConsole::AuthorizationReply>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::AuthorizationRequest* request, ::RemoteConsole::AuthorizationReply* response) { return this->clientAuthorization(context, request, response); }));}
    void SetMessageAllocatorFor_clientAuthorization(
        ::grpc::MessageAllocator< ::RemoteConsole::AuthorizationRequest, ::RemoteConsole::AuthorizationReply>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::AuthorizationRequest, ::RemoteConsole::AuthorizationReply>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clientAuthorization(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_primaryConnection<WithCallbackMethod_clientAuthorization<Service > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_primaryConnection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_primaryConnection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestprimaryConnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclientAuthorization(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_primaryConnection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->primaryConnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* primaryConnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clientAuthorization(context, request, response); }));
    }
    ~WithRawCallbackMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clientAuthorization(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_primaryConnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_primaryConnection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::AuthorizationReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::AuthorizationReply>* streamer) {
                       return this->StreamedprimaryConnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_primaryConnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status primaryConnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedprimaryConnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::Empty,::RemoteConsole::AuthorizationReply>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clientAuthorization : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clientAuthorization() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::AuthorizationRequest, ::RemoteConsole::AuthorizationReply>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::AuthorizationRequest, ::RemoteConsole::AuthorizationReply>* streamer) {
                       return this->StreamedclientAuthorization(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clientAuthorization() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clientAuthorization(::grpc::ServerContext* /*context*/, const ::RemoteConsole::AuthorizationRequest* /*request*/, ::RemoteConsole::AuthorizationReply* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclientAuthorization(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::AuthorizationRequest,::RemoteConsole::AuthorizationReply>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_primaryConnection<WithStreamedUnaryMethod_clientAuthorization<Service > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_primaryConnection<WithStreamedUnaryMethod_clientAuthorization<Service > > StreamedService;
};

class EventDetectionService final {
 public:
  static constexpr char const* service_full_name() {
    return "RemoteConsole.EventDetectionService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // Detection of mouse and keyboard events from client side 
    virtual ::grpc::Status keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::RemoteConsole::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> AsynckeyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(AsynckeyDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> PrepareAsynckeyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(PrepareAsynckeyDetectionRaw(context, request, cq));
    }
    virtual ::grpc::Status mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::RemoteConsole::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> AsyncmouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(AsyncmouseDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> PrepareAsyncmouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(PrepareAsyncmouseDetectionRaw(context, request, cq));
    }
    virtual ::grpc::Status clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> AsyncclientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(AsyncclientDisconnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> PrepareAsyncclientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(PrepareAsyncclientDisconnectionRaw(context, request, cq));
    }
    virtual ::grpc::Status connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> AsyncconnectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(AsyncconnectionAliveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> PrepareAsyncconnectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(PrepareAsyncconnectionAliveRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // Detection of mouse and keyboard events from client side 
      virtual void keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* AsynckeyDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* PrepareAsynckeyDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* AsyncmouseDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* PrepareAsyncmouseDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* AsyncclientDisconnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* PrepareAsyncclientDisconnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* AsyncconnectionAliveRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* PrepareAsyncconnectionAliveRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::RemoteConsole::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> AsynckeyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(AsynckeyDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> PrepareAsynckeyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(PrepareAsynckeyDetectionRaw(context, request, cq));
    }
    ::grpc::Status mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::RemoteConsole::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> AsyncmouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(AsyncmouseDetectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> PrepareAsyncmouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(PrepareAsyncmouseDetectionRaw(context, request, cq));
    }
    ::grpc::Status clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> AsyncclientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(AsyncclientDisconnectionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> PrepareAsyncclientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(PrepareAsyncclientDisconnectionRaw(context, request, cq));
    }
    ::grpc::Status connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> AsyncconnectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(AsyncconnectionAliveRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> PrepareAsyncconnectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(PrepareAsyncconnectionAliveRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) override;
      void keyDetection(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) override;
      void mouseDetection(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) override;
      void clientDisconnection(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) override;
      void connectionAlive(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* AsynckeyDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* PrepareAsynckeyDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::KeyEventMess& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* AsyncmouseDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* PrepareAsyncmouseDetectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::MouseEventMess& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* AsyncclientDisconnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* PrepareAsyncclientDisconnectionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* AsyncconnectionAliveRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* PrepareAsyncconnectionAliveRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_keyDetection_;
    const ::grpc::internal::RpcMethod rpcmethod_mouseDetection_;
    const ::grpc::internal::RpcMethod rpcmethod_clientDisconnection_;
    const ::grpc::internal::RpcMethod rpcmethod_connectionAlive_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // Detection of mouse and keyboard events from client side 
    virtual ::grpc::Status keyDetection(::grpc::ServerContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response);
    virtual ::grpc::Status mouseDetection(::grpc::ServerContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response);
    virtual ::grpc::Status clientDisconnection(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response);
    virtual ::grpc::Status connectionAlive(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_keyDetection() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestkeyDetection(::grpc::ServerContext* context, ::RemoteConsole::KeyEventMess* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_mouseDetection() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmouseDetection(::grpc::ServerContext* context, ::RemoteConsole::MouseEventMess* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclientDisconnection(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_connectionAlive() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestconnectionAlive(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_keyDetection<WithAsyncMethod_mouseDetection<WithAsyncMethod_clientDisconnection<WithAsyncMethod_connectionAlive<Service > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_keyDetection() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::KeyEventMess, ::RemoteConsole::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::KeyEventMess* request, ::RemoteConsole::Empty* response) { return this->keyDetection(context, request, response); }));}
    void SetMessageAllocatorFor_keyDetection(
        ::grpc::MessageAllocator< ::RemoteConsole::KeyEventMess, ::RemoteConsole::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::KeyEventMess, ::RemoteConsole::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* keyDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_mouseDetection() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::MouseEventMess, ::RemoteConsole::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::MouseEventMess* request, ::RemoteConsole::Empty* response) { return this->mouseDetection(context, request, response); }));}
    void SetMessageAllocatorFor_mouseDetection(
        ::grpc::MessageAllocator< ::RemoteConsole::MouseEventMess, ::RemoteConsole::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::MouseEventMess, ::RemoteConsole::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* mouseDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response) { return this->clientDisconnection(context, request, response); }));}
    void SetMessageAllocatorFor_clientDisconnection(
        ::grpc::MessageAllocator< ::RemoteConsole::Empty, ::RemoteConsole::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clientDisconnection(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_connectionAlive() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response) { return this->connectionAlive(context, request, response); }));}
    void SetMessageAllocatorFor_connectionAlive(
        ::grpc::MessageAllocator< ::RemoteConsole::Empty, ::RemoteConsole::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* connectionAlive(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_keyDetection<WithCallbackMethod_mouseDetection<WithCallbackMethod_clientDisconnection<WithCallbackMethod_connectionAlive<Service > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_keyDetection() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_mouseDetection() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_connectionAlive() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_keyDetection() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestkeyDetection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_mouseDetection() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestmouseDetection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestclientDisconnection(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_connectionAlive() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestconnectionAlive(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_keyDetection() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->keyDetection(context, request, response); }));
    }
    ~WithRawCallbackMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* keyDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_mouseDetection() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->mouseDetection(context, request, response); }));
    }
    ~WithRawCallbackMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* mouseDetection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->clientDisconnection(context, request, response); }));
    }
    ~WithRawCallbackMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* clientDisconnection(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_connectionAlive() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->connectionAlive(context, request, response); }));
    }
    ~WithRawCallbackMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* connectionAlive(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_keyDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_keyDetection() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::KeyEventMess, ::RemoteConsole::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::KeyEventMess, ::RemoteConsole::Empty>* streamer) {
                       return this->StreamedkeyDetection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_keyDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status keyDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::KeyEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedkeyDetection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::KeyEventMess,::RemoteConsole::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_mouseDetection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_mouseDetection() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::MouseEventMess, ::RemoteConsole::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::MouseEventMess, ::RemoteConsole::Empty>* streamer) {
                       return this->StreamedmouseDetection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_mouseDetection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status mouseDetection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::MouseEventMess* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedmouseDetection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::MouseEventMess,::RemoteConsole::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_clientDisconnection : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_clientDisconnection() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::Empty>* streamer) {
                       return this->StreamedclientDisconnection(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_clientDisconnection() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status clientDisconnection(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedclientDisconnection(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::Empty,::RemoteConsole::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_connectionAlive : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_connectionAlive() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::Empty>* streamer) {
                       return this->StreamedconnectionAlive(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_connectionAlive() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status connectionAlive(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedconnectionAlive(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::Empty,::RemoteConsole::Empty>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_keyDetection<WithStreamedUnaryMethod_mouseDetection<WithStreamedUnaryMethod_clientDisconnection<WithStreamedUnaryMethod_connectionAlive<Service > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_keyDetection<WithStreamedUnaryMethod_mouseDetection<WithStreamedUnaryMethod_clientDisconnection<WithStreamedUnaryMethod_connectionAlive<Service > > > > StreamedService;
};

class ConsoleControllService final {
 public:
  static constexpr char const* service_full_name() {
    return "RemoteConsole.ConsoleControllService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // The server send to the client console screen buffer
    std::unique_ptr< ::grpc::ClientReaderInterface< ::RemoteConsole::CharChank>> SendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::RemoteConsole::CharChank>>(SendCharInfoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>> AsyncSendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>>(AsyncSendCharInfoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>> PrepareAsyncSendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>>(PrepareAsyncSendCharInfoRaw(context, request, cq));
    }
    virtual ::grpc::Status CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> AsyncCheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(AsyncCheckBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>> PrepareAsyncCheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>>(PrepareAsyncCheckBufferRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::CursorMess* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>> AsyncGetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>>(AsyncGetCirsorPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>> PrepareAsyncGetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>>(PrepareAsyncGetCirsorPositionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      // The server send to the client console screen buffer
      virtual void SendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::grpc::ClientReadReactor< ::RemoteConsole::CharChank>* reactor) = 0;
      virtual void CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::RemoteConsole::CharChank>* SendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>* AsyncSendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::RemoteConsole::CharChank>* PrepareAsyncSendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* AsyncCheckBufferRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::Empty>* PrepareAsyncCheckBufferRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>* AsyncGetCirsorPositionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::RemoteConsole::CursorMess>* PrepareAsyncGetCirsorPositionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::RemoteConsole::CharChank>> SendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::RemoteConsole::CharChank>>(SendCharInfoRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>> AsyncSendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>>(AsyncSendCharInfoRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>> PrepareAsyncSendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>>(PrepareAsyncSendCharInfoRaw(context, request, cq));
    }
    ::grpc::Status CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> AsyncCheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(AsyncCheckBufferRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>> PrepareAsyncCheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>>(PrepareAsyncCheckBufferRaw(context, request, cq));
    }
    ::grpc::Status GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::RemoteConsole::CursorMess* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>> AsyncGetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>>(AsyncGetCirsorPositionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>> PrepareAsyncGetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>>(PrepareAsyncGetCirsorPositionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void SendCharInfo(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::grpc::ClientReadReactor< ::RemoteConsole::CharChank>* reactor) override;
      void CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, std::function<void(::grpc::Status)>) override;
      void CheckBuffer(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response, ::grpc::ClientUnaryReactor* reactor) override;
      void GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response, std::function<void(::grpc::Status)>) override;
      void GetCirsorPosition(::grpc::ClientContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::RemoteConsole::CharChank>* SendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request) override;
    ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>* AsyncSendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::RemoteConsole::CharChank>* PrepareAsyncSendCharInfoRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* AsyncCheckBufferRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::Empty>* PrepareAsyncCheckBufferRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>* AsyncGetCirsorPositionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::RemoteConsole::CursorMess>* PrepareAsyncGetCirsorPositionRaw(::grpc::ClientContext* context, const ::RemoteConsole::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_SendCharInfo_;
    const ::grpc::internal::RpcMethod rpcmethod_CheckBuffer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCirsorPosition_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // The server send to the client console screen buffer
    virtual ::grpc::Status SendCharInfo(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* writer);
    virtual ::grpc::Status CheckBuffer(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response);
    virtual ::grpc::Status GetCirsorPosition(::grpc::ServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCharInfo(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncWriter< ::RemoteConsole::CharChank>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckBuffer(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCirsorPosition(::grpc::ServerContext* context, ::RemoteConsole::Empty* request, ::grpc::ServerAsyncResponseWriter< ::RemoteConsole::CursorMess>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_SendCharInfo<WithAsyncMethod_CheckBuffer<WithAsyncMethod_GetCirsorPosition<Service > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::RemoteConsole::Empty, ::RemoteConsole::CharChank>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request) { return this->SendCharInfo(context, request); }));
    }
    ~WithCallbackMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::RemoteConsole::CharChank>* SendCharInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::Empty* response) { return this->CheckBuffer(context, request, response); }));}
    void SetMessageAllocatorFor_CheckBuffer(
        ::grpc::MessageAllocator< ::RemoteConsole::Empty, ::RemoteConsole::Empty>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::Empty>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckBuffer(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::CursorMess>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::RemoteConsole::Empty* request, ::RemoteConsole::CursorMess* response) { return this->GetCirsorPosition(context, request, response); }));}
    void SetMessageAllocatorFor_GetCirsorPosition(
        ::grpc::MessageAllocator< ::RemoteConsole::Empty, ::RemoteConsole::CursorMess>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::RemoteConsole::Empty, ::RemoteConsole::CursorMess>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCirsorPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_SendCharInfo<WithCallbackMethod_CheckBuffer<WithCallbackMethod_GetCirsorPosition<Service > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendCharInfo(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCheckBuffer(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCirsorPosition(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->SendCharInfo(context, request); }));
    }
    ~WithRawCallbackMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* SendCharInfo(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CheckBuffer(context, request, response); }));
    }
    ~WithRawCallbackMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CheckBuffer(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCirsorPosition(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetCirsorPosition(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CheckBuffer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CheckBuffer() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::Empty>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::Empty>* streamer) {
                       return this->StreamedCheckBuffer(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CheckBuffer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CheckBuffer(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::Empty* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCheckBuffer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::Empty,::RemoteConsole::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCirsorPosition : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCirsorPosition() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::CursorMess>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::CursorMess>* streamer) {
                       return this->StreamedGetCirsorPosition(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCirsorPosition() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCirsorPosition(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::RemoteConsole::CursorMess* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCirsorPosition(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::RemoteConsole::Empty,::RemoteConsole::CursorMess>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_CheckBuffer<WithStreamedUnaryMethod_GetCirsorPosition<Service > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_SendCharInfo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_SendCharInfo() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::RemoteConsole::Empty, ::RemoteConsole::CharChank>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::RemoteConsole::Empty, ::RemoteConsole::CharChank>* streamer) {
                       return this->StreamedSendCharInfo(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_SendCharInfo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendCharInfo(::grpc::ServerContext* /*context*/, const ::RemoteConsole::Empty* /*request*/, ::grpc::ServerWriter< ::RemoteConsole::CharChank>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedSendCharInfo(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::RemoteConsole::Empty,::RemoteConsole::CharChank>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_SendCharInfo<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_SendCharInfo<WithStreamedUnaryMethod_CheckBuffer<WithStreamedUnaryMethod_GetCirsorPosition<Service > > > StreamedService;
};

}  // namespace RemoteConsole


#endif  // GRPC_RemoteConsole_2eproto__INCLUDED
